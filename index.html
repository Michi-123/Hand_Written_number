<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Hand‑Written Number – Mobile Canvas</title>
  <style>
    :root {
      --toolbar-h: 88px;
      --radius: 14px;
      --shadow: 0 6px 16px rgba(0,0,0,.08);
      --border: 1px solid #d7dbe7;
    }
    html, body { height: 100%; margin: 0; background: #f6f7fb; color: #111; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP"; -webkit-tap-highlight-color: transparent; }
    .wrap { position: fixed; inset: 0; display: grid; grid-template-rows: var(--toolbar-h) 1fr; }
    header { display: flex; align-items: center; gap: 10px; padding: calc(env(safe-area-inset-top) + 8px) 10px 10px; background: #fff; box-shadow: var(--shadow); z-index: 2; }
    header .title { font-weight: 700; margin-right: 8px; white-space: nowrap; }
    header .spacer { flex: 1; }
    .toolbar { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    button, select, input[type="range"], input[type="color"], label.opt { height: 44px; border-radius: 12px; border: var(--border); background: #fff; padding: 0 12px; font-size: 15px; }
    button { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button.ghost { background: #fff; }
    button:active { transform: translateY(1px); }
    label.opt { display: inline-flex; align-items: center; gap: 8px; padding: 0 8px; }
    #board { position: relative; background: #fff; margin: 10px; margin-bottom: calc(10px + env(safe-area-inset-bottom)); border-radius: var(--radius); box-shadow: var(--shadow); overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; /* touch-action is controlled dynamically in JS */ }
    .hint { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,.55); color: #fff; font-size: 12px; padding: 6px 10px; border-radius: 999px; pointer-events: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">📱 手書きキャンバス（スマホ最適化）</div>
      <div class="toolbar">
        <button id="penBtn" class="primary" title="ペン">ペン</button>
        <button id="eraserBtn" class="ghost" title="消しゴム">消しゴム</button>
        <label class="opt" title="色"><span>色</span><input id="color" type="color" value="#111111" /></label>
        <label class="opt" title="太さ"><span>太さ</span><input id="size" type="range" min="2" max="48" step="1" value="14" /></label>
        <label class="opt" title="筆圧対応"><input id="pressure" type="checkbox" checked />筆圧</label>
        <button id="undoBtn" class="ghost" title="一つ戻す">↶ 戻す</button>
        <button id="redoBtn" class="ghost" title="やり直し">↷ 進む</button>
        <button id="clearBtn" class="ghost" title="全消去">🗑 全消去</button>
        <button id="saveBtn" class="ghost" title="PNG保存">💾 PNG</button>
      </div>
      <div class="spacer"></div>
    </header>
    <div id="board">
      <canvas id="canvas"></canvas>
      <div class="hint">1本指で描画 / 指を離すとスクロール可能</div>
    </div>
  </div>  <script>
  (() => {
    const canvas = document.getElementById('canvas');
    const board = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha: true });

    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const colorEl = document.getElementById('color');
    const sizeEl = document.getElementById('size');
    const pressureEl = document.getElementById('pressure');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');

    // ====== スマホ最適化のポイント ======
    // ・DPRに合わせた高精細スケーリング
    // ・描画中のみ touch-action: none（それ以外は pan-y pinch-zoom を許可）
    // ・シングルタッチのみ描画（他の指は無視）

    let tool = 'pen'; // 'pen' | 'eraser'
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    const defaultTouchAction = 'pan-y pinch-zoom';
    canvas.style.touchAction = defaultTouchAction;

    const state = {
      strokes: [], // { tool, color, size, points:[{x,y,p,t}] }
      redo: [],
      drawing: false,
      activeStroke: null,
      activePointerId: null,
    };

    function cssSize() {
      const style = getComputedStyle(board);
      const w = board.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
      // 画面高−ヘッダ−マージンでキャンバス高さを算出
      const headerH = document.querySelector('header').getBoundingClientRect().height;
      const h = Math.max(240, window.innerHeight - headerH - 20 - (parseFloat(getComputedStyle(board).marginBottom) || 0));
      return { w: Math.max(240, w), h };
    }

    function resizeCanvas(preserve = true) {
      const { w, h } = cssSize();
      let snapshot = null;
      if (preserve && canvas.width > 0 && canvas.height > 0) {
        try { snapshot = canvas.toDataURL('image/png'); } catch {}
      }
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      if (snapshot) {
        const img = new Image();
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); };
        img.src = snapshot;
      } else {
        redraw();
      }
    }

    function setTool(next) {
      tool = next;
      penBtn.classList.toggle('primary', tool === 'pen');
      eraserBtn.classList.toggle('primary', tool === 'eraser');
      penBtn.classList.toggle('ghost', tool !== 'pen');
      eraserBtn.classList.toggle('ghost', tool !== 'eraser');
    }

    function pressureWidth(p) {
      if (!pressureEl.checked) return parseInt(sizeEl.value, 10);
      const base = parseInt(sizeEl.value, 10);
      const q = (p > 0 ? p : 0.5); // 0..1（非対応端末は0.5相当）
      return Math.max(1, Math.round(base * (0.5 + 0.7 * q)));
    }

    function ptFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left),
        y: (e.clientY - rect.top),
        p: e.pressure ?? 0,
        t: performance.now()
      };
    }

    function startStroke(e) {
      // 既に別の指で描画中なら無視
      if (state.activePointerId !== null && e.pointerId !== state.activePointerId) return;
      state.activePointerId = e.pointerId;
      state.drawing = true;
      state.redo.length = 0;
      const stroke = { tool, color: colorEl.value, size: parseInt(sizeEl.value, 10), points: [] };
      state.activeStroke = stroke;
      state.strokes.push(stroke);
      canvas.style.touchAction = 'none'; // 描画中はスクロール無効
      try { canvas.setPointerCapture(e.pointerId); } catch {}
      addPoint(e);
    }

    function addPoint(e) {
      if (!state.drawing || !state.activeStroke) return;
      if (e.pointerId !== state.activePointerId) return;
      const pt = ptFromEvent(e);
      state.activeStroke.points.push(pt);
      drawLastSegment(state.activeStroke);
    }

    function endStroke(e) {
      if (e && e.pointerId !== state.activePointerId) return;
      state.drawing = false;
      state.activeStroke = null;
      try { canvas.releasePointerCapture(state.activePointerId); } catch {}
      state.activePointerId = null;
      canvas.style.touchAction = defaultTouchAction; // スクロール再有効化
    }

    function drawLastSegment(stroke) {
      const pts = stroke.points;
      if (pts.length < 2) return;
      const n = pts.length;
      const p0 = pts[n - 2];
      const p1 = pts[n - 1];
      const midX = (p0.x + p1.x) / 2;
      const midY = (p0.y + p1.y) / 2;
      ctx.save();
      if (stroke.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = stroke.color;
      }
      ctx.lineWidth = pressureWidth(p1.p);
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
      ctx.stroke();
      ctx.restore();
    }

    function redraw() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, w, h);
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      for (const stroke of state.strokes) {
        const pts = stroke.points;
        if (pts.length === 0) continue;
        ctx.save();
        if (stroke.tool === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = stroke.color;
        }
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) {
          const p0 = pts[i - 1];
          const p1 = pts[i];
          const midX = (p0.x + p1.x) / 2;
          const midY = (p0.y + p1.y) / 2;
          ctx.lineWidth = pressureWidth(p1.p);
          ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
        }
        ctx.stroke();
        ctx.restore();
      }
      ctx.restore();
    }

    function undo() {
      if (state.strokes.length) { state.redo.push(state.strokes.pop()); redraw(); }
    }
    function redo() {
      if (state.redo.length) { state.strokes.push(state.redo.pop()); redraw(); }
    }

    function clearAll() { state.strokes.length = 0; state.redo.length = 0; redraw(); }

    function savePNG() {
      const w = canvas.clientWidth; const h = canvas.clientHeight;
      const out = document.createElement('canvas');
      out.width = Math.floor(w * dpr); out.height = Math.floor(h * dpr);
      const octx = out.getContext('2d');
      octx.setTransform(dpr, 0, 0, dpr, 0, 0);
      octx.fillStyle = '#ffffff'; octx.fillRect(0, 0, w, h);
      const dataURL = canvas.toDataURL('image/png');
      const img = new Image();
      img.onload = () => {
        octx.drawImage(img, 0, 0, w, h);
        const url = out.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url; a.download = `handwriting_${Date.now()}.png`;
        document.body.appendChild(a); a.click(); a.remove();
      };
      img.src = dataURL;
    }

    // ====== Pointer / Touch Events ======
    canvas.addEventListener('pointerdown', (e) => { if (e.isPrimary || e.pointerType !== 'touch') startStroke(e); });
    canvas.addEventListener('pointermove', (e) => addPoint(e));
    canvas.addEventListener('pointerup', (e) => endStroke(e));
    canvas.addEventListener('pointercancel', (e) => endStroke(e));
    canvas.addEventListener('pointerleave', (e) => endStroke(e));

    // iOS Safari での2本指操作を妨げない（描画中以外）
    document.addEventListener('touchstart', (e) => { /* passive でスクロール許可 */ }, { passive: true });

    // ====== Controls ======
    penBtn.addEventListener('click', () => setTool('pen'));
    eraserBtn.addEventListener('click', () => setTool('eraser'));
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    clearBtn.addEventListener('click', clearAll);
    saveBtn.addEventListener('click', savePNG);

    // ====== Resize ======
    const ro = new ResizeObserver(() => resizeCanvas(true));
    ro.observe(board);
    window.addEventListener('orientationchange', () => setTimeout(() => resizeCanvas(true), 200));
    window.addEventListener('resize', () => resizeCanvas(true));

    // Init
    setTool('pen');
    resizeCanvas(false);
  })();
  </script></body>
</html>
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Hand‑Written Number – Mobile Canvas</title>
  <style>
    :root {
      --toolbar-h: 88px;
      --radius: 14px;
      --shadow: 0 6px 16px rgba(0,0,0,.08);
      --border: 1px solid #d7dbe7;
    }
    html, body { height: 100%; margin: 0; background: #f6f7fb; color: #111; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP"; -webkit-tap-highlight-color: transparent; }
    .wrap { position: fixed; inset: 0; display: grid; grid-template-rows: var(--toolbar-h) 1fr; }
    header { display: flex; align-items: center; gap: 10px; padding: calc(env(safe-area-inset-top) + 8px) 10px 10px; background: #fff; box-shadow: var(--shadow); z-index: 2; }
    header .title { font-weight: 700; margin-right: 8px; white-space: nowrap; }
    header .spacer { flex: 1; }
    .toolbar { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    button, select, input[type="range"], input[type="color"], label.opt { height: 44px; border-radius: 12px; border: var(--border); background: #fff; padding: 0 12px; font-size: 15px; }
    button { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button.ghost { background: #fff; }
    button:active { transform: translateY(1px); }
    label.opt { display: inline-flex; align-items: center; gap: 8px; padding: 0 8px; }
    #board { position: relative; background: #fff; margin: 10px; margin-bottom: calc(10px + env(safe-area-inset-bottom)); border-radius: var(--radius); box-shadow: var(--shadow); overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; /* touch-action is controlled dynamically in JS */ }
    .hint { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,.55); color: #fff; font-size: 12px; padding: 6px 10px; border-radius: 999px; pointer-events: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">📱 手書きキャンバス（スマホ最適化）</div>
      <div class="toolbar">
        <button id="penBtn" class="primary" title="ペン">ペン</button>
        <button id="eraserBtn" class="ghost" title="消しゴム">消しゴム</button>
        <label class="opt" title="色"><span>色</span><input id="color" type="color" value="#111111" /></label>
        <label class="opt" title="太さ"><span>太さ</span><input id="size" type="range" min="2" max="48" step="1" value="14" /></label>
        <label class="opt" title="筆圧対応"><input id="pressure" type="checkbox" checked />筆圧</label>
        <button id="undoBtn" class="ghost" title="一つ戻す">↶ 戻す</button>
        <button id="redoBtn" class="ghost" title="やり直し">↷ 進む</button>
        <button id="clearBtn" class="ghost" title="全消去">🗑 全消去</button>
        <button id="saveBtn" class="ghost" title="PNG保存">💾 PNG</button>
      </div>
      <div class="spacer"></div>
    </header>
    <div id="board">
      <canvas id="canvas"></canvas>
      <div class="hint">1本指で描画 / 指を離すとスクロール可能</div>
    </div>
  </div>  <script>
  (() => {
    const canvas = document.getElementById('canvas');
    const board = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha: true });

    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const colorEl = document.getElementById('color');
    const sizeEl = document.getElementById('size');
    const pressureEl = document.getElementById('pressure');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');

    // ====== スマホ最適化のポイント ======
    // ・DPRに合わせた高精細スケーリング
    // ・描画中のみ touch-action: none（それ以外は pan-y pinch-zoom を許可）
    // ・シングルタッチのみ描画（他の指は無視）

    let tool = 'pen'; // 'pen' | 'eraser'
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    const defaultTouchAction = 'pan-y pinch-zoom';
    canvas.style.touchAction = defaultTouchAction;

    const state = {
      strokes: [], // { tool, color, size, points:[{x,y,p,t}] }
      redo: [],
      drawing: false,
      activeStroke: null,
      activePointerId: null,
    };

    function cssSize() {
      const style = getComputedStyle(board);
      const w = board.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
      // 画面高−ヘッダ−マージンでキャンバス高さを算出
      const headerH = document.querySelector('header').getBoundingClientRect().height;
      const h = Math.max(240, window.innerHeight - headerH - 20 - (parseFloat(getComputedStyle(board).marginBottom) || 0));
      return { w: Math.max(240, w), h };
    }

    function resizeCanvas(preserve = true) {
      const { w, h } = cssSize();
      let snapshot = null;
      if (preserve && canvas.width > 0 && canvas.height > 0) {
        try { snapshot = canvas.toDataURL('image/png'); } catch {}
      }
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      if (snapshot) {
        const img = new Image();
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); };
        img.src = snapshot;
      } else {
        redraw();
      }
    }

    function setTool(next) {
      tool = next;
      penBtn.classList.toggle('primary', tool === 'pen');
      eraserBtn.classList.toggle('primary', tool === 'eraser');
      penBtn.classList.toggle('ghost', tool !== 'pen');
      eraserBtn.classList.toggle('ghost', tool !== 'eraser');
    }

    function pressureWidth(p) {
      if (!pressureEl.checked) return parseInt(sizeEl.value, 10);
      const base = parseInt(sizeEl.value, 10);
      const q = (p > 0 ? p : 0.5); // 0..1（非対応端末は0.5相当）
      return Math.max(1, Math.round(base * (0.5 + 0.7 * q)));
    }

    function ptFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left),
        y: (e.clientY - rect.top),
        p: e.pressure ?? 0,
        t: performance.now()
      };
    }

    function startStroke(e) {
      // 既に別の指で描画中なら無視
      if (state.activePointerId !== null && e.pointerId !== state.activePointerId) return;
      state.activePointerId = e.pointerId;
      state.drawing = true;
      state.redo.length = 0;
      const stroke = { tool, color: colorEl.value, size: parseInt(sizeEl.value, 10), points: [] };
      state.activeStroke = stroke;
      state.strokes.push(stroke);
      canvas.style.touchAction = 'none'; // 描画中はスクロール無効
      try { canvas.setPointerCapture(e.pointerId); } catch {}
      addPoint(e);
    }

    function addPoint(e) {
      if (!state.drawing || !state.activeStroke) return;
      if (e.pointerId !== state.activePointerId) return;
      const pt = ptFromEvent(e);
      state.activeStroke.points.push(pt);
      drawLastSegment(state.activeStroke);
    }

    function endStroke(e) {
      if (e && e.pointerId !== state.activePointerId) return;
      state.drawing = false;
      state.activeStroke = null;
      try { canvas.releasePointerCapture(state.activePointerId); } catch {}
      state.activePointerId = null;
      canvas.style.touchAction = defaultTouchAction; // スクロール再有効化
    }

    function drawLastSegment(stroke) {
      const pts = stroke.points;
      if (pts.length < 2) return;
      const n = pts.length;
      const p0 = pts[n - 2];
      const p1 = pts[n - 1];
      const midX = (p0.x + p1.x) / 2;
 
